---
applyTo: "**"
---

## 目的

このリポジトリでは、Copilot（AI 支援）が出力するコード/提案が **最小の変更で、既存設計を壊さず、シンプルに進む**ことを最優先とする。

---

## 基本方針

- **変更は最小限**：目的達成に必要な最小の差分だけを提案・実装する
- **勝手に変更しない**：指示されていないファイルは編集しない（例：整形だけの変更、不要なリネーム、依存追加などは禁止）
- **余計なコードを増やさない**：将来の拡張を見越した抽象化・汎用化・共通化を先回りで入れない
- **シンプル最優先**：贅沢な機能より、読みやすく・壊れにくい構造を選ぶ

---

## コードサイズ制限

- **新規コード追加は 50 行以内**：一度に追加するコードは 50 行を上限とする
- **目的ごとに分割**：複数の目的がある場合は、目的ごとに分けて追加する
- **小さく作って加える**：大きな機能も小さな単位に分割して段階的に実装する
- **変更も目的ごと**：既存コードの変更も、1 つの目的につき 1 回の変更とする

---

## ファイル変更ルール

- 変更対象は **指示されたファイル（または目的達成に必須のファイル）に限定**する
- 既存の挙動に影響する可能性がある変更（設定ファイル、ワークフロー、権限、Secrets 参照など）は、必ず理由を明記する
- フォーマットや並び順の変更など、**意味のない差分**は作らない
- 新規ファイル追加は、**必要性が明確な場合のみ**行う（追加した理由をコメントまたは説明に残す）

---

## コード設計ルール

- まずは **最短で動く実装**を優先する
- 追加機能（例：dry-run、詳細ログ、複雑な設定機構、汎用化）は **要求されるまで入れない**
- 依存関係の追加（npm/pip/apt など）は原則禁止（やむを得ない場合は理由と代替案を提示）
- 「複数のやり方がある」場合は、最もシンプルで保守が容易なものを選ぶ

---

## ディレクトリ構成ルール

- workflow で使用するシェルスクリプトは **step ごとにディレクトリを分ける**
- 例：
  - `scripts/step1_fetch/`
  - `scripts/step2_sync/`
  - `scripts/step3_pr/`

---

## コミット運用ルール

- **コミットメッセージは日本語**で書く
- **コミットメッセージは一言で簡潔に表す**（詳細な説明は不要）
- **コミットメッセージにはプレフィックスを付ける**
  - `feat:` 新機能追加
  - `fix:` バグ修正
  - `docs:` ドキュメント変更
  - `refactor:` リファクタリング
  - `chore:` その他の変更（ビルド、設定など）
- コミットメッセージはプレフィックス + 一文のみ（リストや複数行は不要）
- **小さめのコミット**に分割する（1 コミット = 1 意図）
- 1 コミット内に複数の目的を混ぜない（例：リファクタと機能追加を同梱しない）
- 例（推奨）：
  - `feat: hooks同期workflowを追加`
  - `refactor: テンプレ参照先を環境変数化`
  - `feat: 同期対象を.githooksとinstall-hooks.shに限定`

---

## 出力（提案）フォーマット

Copilot は、提案・変更の際に以下を必ず含める。

1. **何を変えるか（対象ファイル）**
2. **なぜそれが必要か（目的との関係）**
3. **差分が最小である理由**（不要な変更が無いことの説明）
4. **コミット案（日本語）**（短く）

---

## 禁止事項（やらないこと）

- 指示のないファイル修正
- 目的に不要な機能追加（贅沢な機能）
- 不要な抽象化、過度な共通化、将来のための先回り設計
- 不要な依存追加、不要な設定変更
- 大規模なリファクタ（必要になったら小さく分割して提案する）

---

## コーディングルール

- 変数名や関数名は目的駆動の名前を使ってください。
- コメントは適切に追加し、コードの内容を説明するだけのコメントは避けてください。
- マジックナンバーは避け、定数として定義してください。
- 定数は大文字のスネークケースで命名してください。
- コードの可読性を重視してください。
- 生焼けオブジェクトは避けて、コンストラクタで初期化してください。
- 変数は使いまわさず、目的ごとの新しい変数を作成してください。
- データしか持たないクラスは避けてください。
- 目的ごとに関数を分割し、一つの関数に複数の目的を持たせないでください。
- 関数名は動詞で始め、関数の目的を明確にしてください。
- 関係しあうデータとロジックは同じクラスにまとめてください。
- クラス単体で動作するように設計してください。
- 継承は避け、委譲を使用してください。
- デフォルトで不変を採用してください。
- 基本的にインスタンス変数やメソッド引数なども不変にしてください。
- 不正値をガード節で排除してください。
- 値オブジェクトを使用して、ドメインの概念を明確にしてください。
- プリミティブ型の乱用を避けて、クラスを使用してください。
- static メソッドはファクトリメソッドとして使用してください。
- 引数が多すぎる関数は避けてください。
- インスタンス変数ごとにクラスを分割してください。
- 単一責任の原則を守ってください。
- DRY の原則を守ってほしいですが、目的が異なる場合は重複を許容してください。
- 早期リターンでネストを浅くしてください。
- 種類ごとに処理を切り替える場合はポリモーフィズムを使用してください。
- Switch 文が必要な場合は interface を使用することを検討してください。
- 同じような判定条件がある場合、ポリシーパターンを検討してください。
- 型の判定で分岐しないように設計してください。
- マジックナンバーは定数として定義してください。
- マジックストリングは定数として定義してください。
- グローバル変数は使わないでください。
- null 許容しない設計にしてください。
- 例外はキャッチしたら必ずログを出力してください。
- 概念の種類ごとに名前空間を分けてください。
- 関心事にふさわしく、より具体的な目的駆動の命名を使用してください。
